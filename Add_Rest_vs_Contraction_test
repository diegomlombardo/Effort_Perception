%% ========================================================================
%                    ROI–PES CORRELATION ANALYSIS PIPELINE
%                 Publication-quality version (non-overlapping bars)
%                  (with inverted sign of ROI values)
% ========================================================================

%% ----------- SETUP -----------
missing_subjects = [1, 9, 35];
total_subjects   = 47;
valid_subjects   = setdiff(1:total_subjects, missing_subjects);
num_subjects     = length(valid_subjects);

% Define ROI groups
roi_groups.premotor      = [7];        
roi_groups.supplementary = [26];       
roi_groups.sensory       = [17];       
roi_groups.cingulate     = [29, 30];  
roi_groups.insula        = [2];        
roi_groups.dlPFC         = [3, 4];    

group_names = fieldnames(roi_groups);
num_groups  = length(group_names);

% Initialize matrices to store mean BOLD per subject and ROI
bold_task1_contraction = nan(num_subjects, num_groups);
bold_task1_rest        = nan(num_subjects, num_groups);
bold_task2_contraction = nan(num_subjects, num_groups);
bold_task2_rest        = nan(num_subjects, num_groups);

%% ----------- PARAMETERS FOR BLOCK DESIGN -----------
total_time_points = 184;  
contraction_length = 6;   
rest_length = 10;         
num_contractions = 6;

% Logical indexing for contraction and rest blocks
is_contraction = false(total_time_points, 1);
start_tp = 1;
for c = 1:num_contractions
    rest_range = start_tp : min(start_tp + rest_length - 1, total_time_points);
    contraction_start = start_tp + rest_length;
    contraction_range = contraction_start : min(contraction_start + contraction_length - 1, total_time_points);
    is_contraction(contraction_range) = true;
    start_tp = contraction_start + contraction_length;
end
is_rest = ~is_contraction;

%% ----------- LOAD DATA AND CALCULATE CLEAN MEANS -----------
subject_idx = 0;
for subj = 1:total_subjects
    if ismember(subj, missing_subjects)
        continue;
    end
    subject_idx = subject_idx + 1;
    subj_str = sprintf('%02d', subj);
    
    % Load Task 1
    file_task1 = ['ROIs_sub_' subj_str '_task1.mat'];
    data1 = load(file_task1);
    bold1 = data1.bold_data;  % [time x num_ROIs]
    
    % Load Task 2
    file_task2 = ['ROIs_sub_' subj_str '_task2.mat'];
    data2 = load(file_task2);
    bold2 = data2.bold_data;  % [time x num_ROIs]

    %% ---- NORMALIZE TO PERCENT SIGNAL CHANGE ----
    bold1 = 100 * (bold1 - mean(bold1, 1)) ./ mean(bold1, 1);
    bold2 = 100 * (bold2 - mean(bold2, 1)) ./ mean(bold2, 1);

    %% ---- COMPUTE CONDITION MEANS ----
    for g = 1:num_groups
        roi_indices = roi_groups.(group_names{g});
        
        % Restrict indices to existing columns
        roi_indices1 = roi_indices(roi_indices <= size(bold1,2));
        roi_indices2 = roi_indices(roi_indices <= size(bold2,2));
        if isempty(roi_indices1) || isempty(roi_indices2)
            warning('ROI %s not present in data. Skipping.', group_names{g});
            continue;
        end
        
        % ---- TASK 1 ----
        seg1_con = bold1(is_contraction, roi_indices1);
        seg1_con = seg1_con(:);
        seg1_con(isoutlier(seg1_con,'median')) = NaN;
        bold_task1_contraction(subject_idx,g) = mean(seg1_con,'omitnan');

        seg1_rest = bold1(is_rest, roi_indices1);
        seg1_rest = seg1_rest(:);
        seg1_rest(isoutlier(seg1_rest,'median')) = NaN;
        bold_task1_rest(subject_idx,g) = mean(seg1_rest,'omitnan');
        
        % ---- TASK 2 ----
        seg2_con = bold2(is_contraction, roi_indices2);
        seg2_con = seg2_con(:);
        seg2_con(isoutlier(seg2_con,'median')) = NaN;
        bold_task2_contraction(subject_idx,g) = mean(seg2_con,'omitnan');

        seg2_rest = bold2(is_rest, roi_indices2);
        seg2_rest = seg2_rest(:);
        seg2_rest(isoutlier(seg2_rest,'median')) = NaN;
        bold_task2_rest(subject_idx,g) = mean(seg2_rest,'omitnan');
    end
end

%% ----------- INVERT SIGN OF ROI VALUES -----------
% (So that brain–behavior correlations are inverted in sign)
bold_task1_contraction = -bold_task1_contraction;
bold_task1_rest        = -bold_task1_rest;
bold_task2_contraction = -bold_task2_contraction;
bold_task2_rest        = -bold_task2_rest;

%% ----------- ALIGN PES TOTALS SAFELY -----------
fprintf('\n--- Checking PES data consistency ---\n');
fprintf('Length of pes_totals: %d | Expected total subjects: %d | Valid subjects: %d\n', ...
    length(pes_totals), total_subjects, num_subjects);

if length(pes_totals) < total_subjects
    warning('pes_totals has only %d entries (expected %d). Assuming it already excludes missing subjects.', ...
        length(pes_totals), total_subjects);
    pes_clean = pes_totals;
elseif length(pes_totals) == total_subjects
    pes_clean = pes_totals(valid_subjects);
else
    error('Unexpected length of pes_totals: %d. Please verify your PES data.', length(pes_totals));
end

if length(pes_clean) ~= num_subjects
    error('Mismatch: pes_clean (%d) and valid subjects (%d) differ in length.', ...
        length(pes_clean), num_subjects);
end
fprintf('✓ PES data aligned correctly.\n\n');

%% ----------- CORRELATIONS (with p-values) -----------
corr_task1_con = nan(1,num_groups);  p_task1_con = nan(1,num_groups);
corr_task1_rest = nan(1,num_groups); p_task1_rest = nan(1,num_groups);
corr_task2_con = nan(1,num_groups);  p_task2_con = nan(1,num_groups);
corr_task2_rest = nan(1,num_groups); p_task2_rest = nan(1,num_groups);

for g = 1:num_groups
    % Task 1 Contraction
    idx = ~isnan(bold_task1_contraction(:,g)) & ~isnan(pes_clean);
    if sum(idx) > 1
        [corr_task1_con(g), p_task1_con(g)] = corr(bold_task1_contraction(idx,g), pes_clean(idx));
    end
    
    % Task 1 Rest
    idx = ~isnan(bold_task1_rest(:,g)) & ~isnan(pes_clean);
    if sum(idx) > 1
        [corr_task1_rest(g), p_task1_rest(g)] = corr(bold_task1_rest(idx,g), pes_clean(idx));
    end

    % Task 2 Contraction
    idx = ~isnan(bold_task2_contraction(:,g)) & ~isnan(pes_clean);
    if sum(idx) > 1
        [corr_task2_con(g), p_task2_con(g)] = corr(bold_task2_contraction(idx,g), pes_clean(idx));
    end

    % Task 2 Rest
    idx = ~isnan(bold_task2_rest(:,g)) & ~isnan(pes_clean);
    if sum(idx) > 1
        [corr_task2_rest(g), p_task2_rest(g)] = corr(bold_task2_rest(idx,g), pes_clean(idx));
    end
end

%% ----------- DISPLAY RESULTS -----------
T = table(group_names, ...
    corr_task1_con', p_task1_con', ...
    corr_task1_rest', p_task1_rest', ...
    corr_task2_con', p_task2_con', ...
    corr_task2_rest', p_task2_rest', ...
    'VariableNames', {'ROI', ...
    'Task1_Contraction_r','Task1_Contraction_p', ...
    'Task1_Rest_r','Task1_Rest_p', ...
    'Task2_Contraction_r','Task2_Contraction_p', ...
    'Task2_Rest_r','Task2_Rest_p'});

disp('Correlation of each ROI (Contraction vs Rest) with PES scores (r and p-values):');
disp(T);

writetable(T, 'ROI_PES_correlations_with_pvalues.csv');
fprintf('\nResults saved to: ROI_PES_correlations_with_pvalues.csv\n');

%% ========================================================================
%                         PUBLICATION-QUALITY PLOT
% ========================================================================

r_all = [corr_task1_con; corr_task1_rest; corr_task2_con; corr_task2_rest]';
p_all = [p_task1_con;   p_task1_rest;   p_task2_con;   p_task2_rest]';
num_conditions = size(r_all,2);

figure('Color','w','Position',[100 100 950 550]); hold on;

% Define a colorblind-friendly palette
colors = [
    0.27 0.49 0.77;  % Task1 Contraction
    0.53 0.80 0.98;  % Task1 Rest
    0.82 0.29 0.29;  % Task2 Contraction
    0.95 0.64 0.64]; % Task2 Rest

% Create grouped bar plot (non-overlapping)
b = bar(r_all, 'grouped'); 
for k = 1:num_conditions
    b(k).FaceColor = colors(k,:);
    b(k).EdgeColor = 'none';
    b(k).FaceAlpha = 0.9;
end

% --- Add significance markers ---
yl = ylim;
y_offset = 0.08 * range(yl);  % vertical spacing above bars
for g = 1:num_groups
    for c = 1:num_conditions
        if ~isnan(p_all(g,c)) && p_all(g,c) < 0.05
            x = b(c).XData(g) + b(c).XOffset;
            y = r_all(g,c);
            % Place asterisk clearly above the bar, not touching it
            text(x, y + y_offset*sign(y + eps), '*', ...
                'HorizontalAlignment', 'center', ...
                'VerticalAlignment', 'bottom', ...
                'FontSize', 16, 'FontWeight', 'bold', ...
                'Color', [0 0 0]);
        end
    end
end

% --- Aesthetic tuning ---
xticks(1:num_groups);
xticklabels(group_names);
ylabel('Correlation (r) with PES', 'FontSize', 14);
title('ROI-wise Correlation between %BOLD and PES (Inverted Sign)', 'FontWeight', 'bold', 'FontSize', 15);
legend({'Task1-Contraction','Task1-Rest','Task2-Contraction','Task2-Rest'}, ...
    'Location','northoutside','Orientation','horizontal','Box','off','FontSize',12);
set(gca,'FontSize',13,'LineWidth',1.2,'Box','off');
grid on;
ylim([-1 1]);

% --- Export high-resolution version ---
set(gcf,'PaperPositionMode','auto');
print('ROI_PES_correlations_publication_inverted','-dpng','-r600');

fprintf('\n✓ Publication-quality figure saved: ROI_PES_correlations_publication_inverted.png\n');
